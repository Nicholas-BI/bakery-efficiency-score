# Measures Overview

This document explains how the **Bakery Story Efficiency Score** works from concept to implementation. The dashboard ranks bakery recipes based on what *you* care about—Profit, Cook Time, Servings, and XP—by letting you assign custom weights. The scoring logic is flexible, explainable, and built entirely in DAX.

[Click here to download the DAX measures](https://raw.githubusercontent.com/Nicholas-BI/bakery-efficiency-score/main/docs/data/dax_measures.xlsx)  

We’ll focus on **how it works**, not just what the measures are.

---

## Step 1: Start With Raw Totals

Each recipe starts with a handful of simple totals:
- How long it takes to cook (`Total Cook Minutes`)
- How many servings it makes (`Total Servings`)
- How much money it brings in (`Total Profit`)
- How much XP it gives (`Total XP`)

These are calculated with basic `SUM` logic over the fact table. Example:

```DAX
Total Income =
SUM(Fact_Bakery[Income])

Total Cost =
SUM(Fact_Bakery[Cost])

Total Profit =
[Total Income] - [Total Cost]
```

---

## Step 2: Normalize Everything

Each metric has wildly different units and scales—minutes, dollars, servings, XP. To make them comparable, we normalize each one into a range between 0 and 1.

The basic idea is:
> Take this recipe’s value and divide it by the maximum value (either for the whole game or just within the selected appliance).

Here's the logic in DAX for normalized profit:

```DAX
Normalized Profit = 
IF(
    HASONEVALUE( Dim_Recipe[Recipe] ),
    DIVIDE(
        [Total Profit],
        MAXX(
            ALL( Dim_Recipe[Recipe] ),
            [Total Profit]
        ),
        0
    ),
    DIVIDE(
        AVERAGEX(
            VALUES( Dim_Recipe[Recipe] ),
            [Total Profit]
        ),
        MAXX(
            ALL( Dim_Appliance[Appliance] ),
            CALCULATE(
                AVERAGEX(
                    VALUES( Dim_Recipe[Recipe] ),
                    [Total Profit]
                )
            )
        ),
        0
    )
)
```

This gives us four context-aware, normalized values:
- `[Normalized Profit]`
- `[Normalized Cook Minutes]`
- `[Normalized Servings]`
- `[Normalized XP]`

Each one tells us: “how good is this recipe *relative to others*?”

---

## Step 3: Apply Player Weights

You choose what you care about. Maybe you're a profit-maximizer. Maybe you want quick batches. Maybe you're grinding XP. The model lets you assign weights between -20 and +20 for each of the four metrics.

These weights are read from the slicers generated by the what-if parameter:

- **Positive weights** mean you want more of something. It boosts the score.
- **Negative weights** mean you want less of something. It lowers the score.
- **Zero weights** mean you don't care. It has no effect.

---

## Step 4: Build the Raw Score

We take the normalized values and raise them to the power of their weights. Positive weights go into the **numerator**. Negative weights go into the **denominator**.

> The more a metric aligns with your preferences, the more it pulls the score in that direction.

Here’s the **full DAX formula** that brings it all together:

```DAX
Raw Efficiency Score = 
VAR PW = SELECTEDVALUE( ProfitWeight[Profit Weight],      0 )
VAR CW = SELECTEDVALUE( CookTimeWeight[Cook Time Weight], 0 )
VAR SW = SELECTEDVALUE( ServingsWeight[Servings Weight],  0 )
VAR XW = SELECTEDVALUE( XPWeight[XP Weight],              0 )

VAR ProfitBase = [Normalized Profit]
VAR CookBase   = [Normalized Cook Minutes]
VAR ServeBase  = [Normalized Servings]
VAR XPBase     = [Normalized XP]

VAR Numerator =
    IF( PW > 0, POWER( ProfitBase, PW ), 1 ) *
    IF( CW > 0, POWER( CookBase,   CW ), 1 ) *
    IF( SW > 0, POWER( ServeBase,  SW ), 1 ) *
    IF( XW > 0, POWER( XPBase,     XW ), 1 )

VAR Denominator =
    IF( PW < 0, POWER( ProfitBase,  -PW ), 1 ) *
    IF( CW < 0, POWER( CookBase,    -CW ), 1 ) *
    IF( SW < 0, POWER( ServeBase,   -SW ), 1 ) *
    IF( XW < 0, POWER( XPBase,      -XW ), 1 )

VAR RawScore = DIVIDE( Numerator, Denominator, 0 )

VAR HasData = COUNTROWS( Fact_Bakery ) > 0

VAR RecipeScore =
    IF( HasData, RawScore, BLANK() )

RETURN
IF(
    ISINSCOPE( Dim_Recipe[Recipe] ),
    RecipeScore,
    MAXX(
        VALUES( Dim_Recipe[Recipe] ),
        RecipeScore
    )
)
```

This lets you generate a personalized score for every recipe in the game, according to your current strategy.

---

## Step 5: Scale the Results

Once the raw scores are calculated, we **scale** them to bring them into a consistent range for easier comparison and visual interpretation.

We normalize the raw scores again, using the maximum score as the new baseline:

```DAX
Scaled Efficiency Score = 
VAR Raw = [Raw Efficiency Score]


VAR MaxInView =
    IF(
        ISINSCOPE( Dim_Recipe[Recipe] ),
        CALCULATE(
            MAXX( ALLSELECTED( Dim_Recipe[Recipe] ), [Raw Efficiency Score] )
        ),
        CALCULATE(
            MAXX( ALLSELECTED( Dim_Appliance[Appliance] ), [Raw Efficiency Score] )
        )
    )

RETURN
DIVIDE( Raw, MaxInView, 0 ) * 100
```

This ensures the best recipe always has a scaled score of **1**, and others fall proportionally below it.

---

## Step 6: Find the Best Recipe

Now that every recipe has a scaled score, we sort them and return the top result in context.

```DAX
Best Recipe = 
VAR PW     = SELECTEDVALUE( ProfitWeight[Profit Weight],      0 )
VAR CW     = SELECTEDVALUE( CookTimeWeight[Cook Time Weight], 0 )
VAR SW     = SELECTEDVALUE( ServingsWeight[Servings Weight],  0 )
VAR XW     = SELECTEDVALUE( XPWeight[XP Weight],              0 )

VAR IsRecipe    = ISINSCOPE( Dim_Recipe[Recipe] )
VAR IsAppliance = ISINSCOPE( Dim_Appliance[Appliance] )
VAR SelAppl     = SELECTEDVALUE( Dim_Appliance[Appliance], "all appliances" )


VAR CandidateRecipes =
    FILTER(
        ALLSELECTED( Dim_Recipe[Recipe] ),
        NOT( ISBLANK( [Scaled Efficiency Score] ) )
    )

VAR NumRec    = COUNTROWS( CandidateRecipes )
VAR ScoreMax  = MAXX( CandidateRecipes, [Scaled Efficiency Score] )
VAR ScoreMin  = MINX( CandidateRecipes, [Scaled Efficiency Score] )
VAR TopRecs   =
    FILTER( CandidateRecipes, [Scaled Efficiency Score] = ScoreMax )
VAR NumTops   = COUNTROWS( TopRecs )


VAR OneName =
    FIRSTNONBLANK( CandidateRecipes, Dim_Recipe[Recipe] )

RETURN
SWITCH(
    TRUE(),
    NumRec = 0,
        "No recipes match current filters",
    PW = 0 && CW = 0 && SW = 0 && XW = 0,
        "All weights are zero; adjust to find a winner, then click column in chart to see KPIs",
    NumRec = 1,
        "Selected recipe: " & OneName,
    ScoreMax = ScoreMin,
        "All recipes tied — try different weights or refine filters",
    NumTops > 1,
        "Top recipes tied: " &
        CONCATENATEX( TopRecs, Dim_Recipe[Recipe], ", " ),
    IsAppliance,
        "Best recipe in " & SelAppl & ": " &
        FIRSTNONBLANK( TopRecs, Dim_Recipe[Recipe] ),
    TRUE(),
        "Best recipe: " &
        FIRSTNONBLANK( TopRecs, Dim_Recipe[Recipe] )
)

```

This handles ties, blanks, and unhelpful filter situations with a friendly message.

---

## Summary of the Logic

1. **Total up raw values** (profit, XP, etc.)
2. **Normalize** everything to a 0–1 range  
   – Single recipe: normalize vs global max  
   – Multiple recipes: normalize vs appliance-level average
3. **Apply weights** to emphasize or de-emphasize traits
4. **Raise values to those weights** and combine
5. **Scale the final scores** to make results proportional
6. **Pick the best result** using that scaled score

All fully dynamic, filter-aware, and powered by DAX.

---

## Future Features

- Add cost of using an appliance (opportunity cost modeling)
- Tornado charts to visualize which weights influence the score most
- Appliance-aware optimal combos

---

### Explore Other Sections

- [`docs/data_model_overview.md`](./docs/data_model_overview.md) – Table relationships  
- [`docs/measures_overview.md`](./docs/measures_overview.md) – DAX logic  
- [`docs/power_query_overview.md`](./docs/power_query_overview.md) – ETL design  
- [`docs/visuals_overview.md`](./docs/visuals_overview.md) – Layout and interactions

---
