# 📊 Measures Overview

This document explains how the **Bakery Story Efficiency Score** works from concept to implementation. The dashboard ranks bakery recipes based on what *you* care about—Profit, Cook Time, Servings, and XP—by letting you assign custom weights. The scoring logic is flexible, explainable, and built entirely in DAX.

We’ll focus on **how it works**, not just what the measures are.

---

## 🧮 Step 1: Start With Raw Totals

Each recipe starts with a handful of simple totals:
- How long it takes to cook (`Total Cook Minutes`)
- How many servings it makes (`Total Servings`)
- How much money it brings in (`Total Profit`)
- How much XP it gives (`Total XP`)

These are calculated with basic `SUM` logic over the fact table. Example:

```DAX
Total Income =
    SUM(Fact_Bakery[Income])

Total Cost =
    SUM(Fact_Bakery[Cost])

Total Profit =
    [Total Income] - [Total Cost]
```

---

## ⚖️ Step 2: Normalize Everything

Each metric has wildly different units and scales—minutes, dollars, servings, XP. To make them comparable, we normalize each one into a range between 1 and 2.

The basic idea is:
> Take this recipe’s value and divide it by the maximum value (either for the whole game or just within the selected appliance). Then shift it up by 1 so the range becomes [1 → 2].

Here's the logic in DAX for normalized profit:

```DAX
Normalized Profit = 

VAR ThisTotal    = [Total Profit]

VAR MaxTotalAll  =
    MAXX(
        ALL( Dim_Recipe[Recipe] ),
        [Total Profit]
    )

VAR MaxTotalAppl =
    MAXX(
        ALL( Dim_Appliance[Appliance] ),
        [Total Profit]
    )

VAR Denominator =
    IF(
        HASONEVALUE( Dim_Appliance[Appliance] ),
        MaxTotalAppl,  
        MaxTotalAll    
    )

RETURN
    1 + DIVIDE( ThisTotal, Denominator, 0 )

```

This gives us four context-aware, normalized values:
- `[Normalized Profit]`
- `[Normalized Cook Minutes]`
- `[Normalized Servings]`
- `[Normalized XP]`

Each one tells us: “how good is this recipe *relative to others*?”

---

## 🎚️ Step 3: Apply Player Weights

You choose what you care about. Maybe you're a profit-maximizer. Maybe you want quick batches. Maybe you're grinding XP. The model lets you assign weights between -20 and +20 for each of the four metrics.

These weights are read from the slicers generated by the what-if parameter:

- **Positive weights** mean you want more of something. It boosts the score.
- **Negative weights** mean you want less of something. It lowers the score.
- **Zero weights** mean you don't care. It has no effect.

---

## 🚀 Step 4: Build the Score

We take the normalized values and raise them to the power of their weights. Positive weights go into the **numerator**. Negative weights go into the **denominator**.

> The more a metric aligns with your preferences, the more it pulls the score in that direction.

Here’s the **full DAX formula** that brings it all together:

```DAX
Efficiency Score (Filtered) = 
VAR PW = SELECTEDVALUE( ProfitWeight[Profit Weight],      0 )
VAR CW = SELECTEDVALUE( CookTimeWeight[Cook Time Weight], 0 )
VAR SW = SELECTEDVALUE( ServingsWeight[Servings Weight],  0 )
VAR XW = SELECTEDVALUE( XPWeight[XP Weight],              0 )

VAR ProfitBase = [Normalized Profit]
VAR CookBase   = [Normalized Cook Minutes]
VAR ServeBase  = [Normalized Servings]
VAR XPBase     = [Normalized XP]

VAR Numerator =
    IF( PW > 0, POWER( ProfitBase, PW ), 1 ) *
    IF( CW > 0, POWER( CookBase,   CW ), 1 ) *
    IF( SW > 0, POWER( ServeBase,  SW ), 1 ) *
    IF( XW > 0, POWER( XPBase,     XW ), 1 )

VAR Denominator =
    IF( PW < 0, POWER( ProfitBase,  -PW ), 1 ) *
    IF( CW < 0, POWER( CookBase,    -CW ), 1 ) *
    IF( SW < 0, POWER( ServeBase,   -SW ), 1 ) *
    IF( XW < 0, POWER( XPBase,      -XW ), 1 )

VAR BaseResult = DIVIDE( Numerator, Denominator, 0 )
VAR HasRows = COUNTROWS(Fact_Bakery)

RETURN IF(HasRows = 0, BLANK(), BaseResult)
```

This lets you generate a personalized score for every recipe in the game, according to your current strategy.

---

## 🥇 Step 5: Find the Best Recipe

Now that every recipe has a score, we sort them and return the top result in context.

```DAX
Best Recipe = 
VAR Recipes =
    FILTER(
        VALUES( Dim_Recipe[Recipe] ),
        NOT ISBLANK( [Efficiency Score (Filtered)] )
    )
RETURN
IF(
    COUNTROWS(Recipes) < 2
        || MINX(Recipes, [Efficiency Score (Filtered)]) = MAXX(Recipes, [Efficiency Score (Filtered)]),
    "Adjust weights or deselect recipe",
    CONCATENATEX(
        TOPN(1, Recipes, [Efficiency Score (Filtered)], DESC),
        Dim_Recipe[Recipe],
        ", "
    )
)
```

This handles ties, blanks, and unhelpful filter situations with a friendly message.

---

## ✅ Summary of the Logic

1. **Total up basic recipe stats** (profit, XP, etc.)
2. **Normalize** everything to a 1–2 range
3. **Apply weights** to emphasize or de-emphasize traits
4. **Raise values to those weights** and combine
5. **Pick the best recipe** using that final score

All fully dynamic, filter-aware, and powered by DAX.

---

## 🛠️ Future Features

- Add cost of using an appliance (opportunity cost modeling)
- Tornado charts to visualize which weights influence the score most
- Appliance-aware optimal combos

---

Want to try it yourself?  
👉 **[Click here to download the .pbix file](https://raw.githubusercontent.com/Nicholas-BI/bakery-efficiency-score/main/docs/bakery_story.pbix)**  
👉 **[Click here to download the DAX measures](https://raw.githubusercontent.com/Nicholas-BI/bakery-efficiency-score/main/docs/dax_measures.xlsx)**
