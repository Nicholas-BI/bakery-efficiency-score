# Measures Overview

This document explains how the **Bakery Story Efficiency Score** works from concept to implementation. The dashboard ranks bakery recipes based on what *you* care aboutâ€”Profit, Cook Time, Servings, and XPâ€”by letting you assign custom weights. The scoring logic is flexible, explainable, and built entirely in DAX.

ðŸ“¥ [Download the DAX measures](https://raw.githubusercontent.com/Nicholas-BI/bakery-efficiency-score/main/docs/data/dax_measures.xlsx)  

Weâ€™ll focus on **how it works**, not just what the measures are.

---

## Step 1: Start With Raw Totals

Each recipe starts with a handful of simple totals:
- How long it takes to cook (`Total Cook Minutes`)
- How many servings it makes (`Total Servings`)
- How much money it brings in (`Total Profit`)
- How much XP it gives (`Total XP`)

These are calculated with basic `SUM` logic over the fact table. Example:

```DAX
Total Income =
SUM(Fact_Bakery[Income])

Total Cost =
SUM(Fact_Bakery[Cost])

Total Profit =
[Total Income] - [Total Cost]
```

---

## Step 2: Normalize Everything

Each metric has wildly different units and scalesâ€”minutes, dollars, servings, XP. To make them comparable, we normalize each one into a range between 0 and 1.

The basic idea is:
> Take this recipeâ€™s value and divide it by the maximum value (either for the whole game or just within the selected appliance).

Here's the logic in DAX for normalized profit:

```DAX
Normalized Profit = 
IF(
    HASONEVALUE( Dim_Recipe[Recipe] ),
    DIVIDE(
        [Total Profit],
        MAXX(
            ALL( Dim_Recipe[Recipe] ),
            [Total Profit]
        ),
        0
    ),
    DIVIDE(
        AVERAGEX(
            VALUES( Dim_Recipe[Recipe] ),
            [Total Profit]
        ),
        MAXX(
            ALL( Dim_Appliance[Appliance] ),
            CALCULATE(
                AVERAGEX(
                    VALUES( Dim_Recipe[Recipe] ),
                    [Total Profit]
                )
            )
        ),
        0
    )
)
```

This gives us four context-aware, normalized values:
- `[Normalized Profit]`
- `[Normalized Cook Minutes]`
- `[Normalized Servings]`
- `[Normalized XP]`

Each one tells us: â€œhow good is this recipe *relative to others*?â€

---

## Step 3: Apply Player Weights

You choose what you care about. Maybe you're a profit-maximizer. Maybe you want quick batches. Maybe you're grinding XP. The model lets you assign weights between -20 and +20 for each of the four metrics.

These weights are read from the slicers generated by the what-if parameter:

- **Positive weights** mean you want more of something. It boosts the score.
- **Negative weights** mean you want less of something. It lowers the score.
- **Zero weights** mean you don't care. It has no effect.

---

## Step 4: Build the Raw Score

We take the normalized values and raise them to the power of their weights. Positive weights go into the **numerator**. Negative weights go into the **denominator**.

> The more a metric aligns with your preferences, the more it pulls the score in that direction.

Hereâ€™s the **full DAX formula** that brings it all together:

```DAX
Raw Efficiency Score = 
VAR PW = SELECTEDVALUE( ProfitWeight[Profit Weight],      0 )
VAR CW = SELECTEDVALUE( CookTimeWeight[Cook Time Weight], 0 )
VAR SW = SELECTEDVALUE( ServingsWeight[Servings Weight],  0 )
VAR XW = SELECTEDVALUE( XPWeight[XP Weight],              0 )

VAR ProfitBase = [Normalized Profit]
VAR CookBase   = [Normalized Cook Minutes]
VAR ServeBase  = [Normalized Servings]
VAR XPBase     = [Normalized XP]

VAR Numerator =
    IF( PW > 0, POWER( ProfitBase, PW ), 1 ) *
    IF( CW > 0, POWER( CookBase,   CW ), 1 ) *
    IF( SW > 0, POWER( ServeBase,  SW ), 1 ) *
    IF( XW > 0, POWER( XPBase,     XW ), 1 )

VAR Denominator =
    IF( PW < 0, POWER( ProfitBase,  -PW ), 1 ) *
    IF( CW < 0, POWER( CookBase,    -CW ), 1 ) *
    IF( SW < 0, POWER( ServeBase,   -SW ), 1 ) *
    IF( XW < 0, POWER( XPBase,      -XW ), 1 )

VAR RawScore = DIVIDE( Numerator, Denominator, 0 )

VAR HasData = COUNTROWS( Fact_Bakery ) > 0

VAR RecipeScore =
    IF( HasData, RawScore, BLANK() )

RETURN
IF(
    ISINSCOPE( Dim_Recipe[Recipe] ),
    RecipeScore,
    MAXX(
        VALUES( Dim_Recipe[Recipe] ),
        RecipeScore
    )
)
```

This lets you generate a personalized score for every recipe in the game, according to your current strategy.

---

## Step 5: Scale the Results

Once the raw scores are calculated, we **scale** them to bring them into a consistent range for easier comparison and visual interpretation.

We normalize the raw scores again, using the maximum score as the new baseline:

```DAX
Scaled Efficiency Score = 
VAR Raw = [Raw Efficiency Score]


VAR MaxInView =
    IF(
        ISINSCOPE( Dim_Recipe[Recipe] ),
        CALCULATE(
            MAXX( ALLSELECTED( Dim_Recipe[Recipe] ), [Raw Efficiency Score] )
        ),
        CALCULATE(
            MAXX( ALLSELECTED( Dim_Appliance[Appliance] ), [Raw Efficiency Score] )
        )
    )

RETURN
DIVIDE( Raw, MaxInView, 0 ) * 100
```

This ensures the best recipe always has a scaled score of **100**, and others fall proportionally below it.

---

## Step 6: Find the Best Recipe

Now that every recipe has a scaled score, we sort them and return the top result in context.

```DAX
Best Recipe =
VAR PW = SELECTEDVALUE( ProfitWeight[Profit Weight],      0 )
VAR CW = SELECTEDVALUE( CookTimeWeight[Cook Time Weight], 0 )
VAR SW = SELECTEDVALUE( ServingsWeight[Servings Weight],  0 )
VAR XW = SELECTEDVALUE( XPWeight[XP Weight],              0 )

VAR SelectedAppliance =
    SELECTEDVALUE( Dim_Appliance[Appliance], "all appliances" )

VAR Recipes =
    FILTER(
        ALLSELECTED( Dim_Recipe[Recipe] ),
        NOT( ISBLANK( [Scaled Efficiency Score] ) )
    )

VAR CountRec    = COUNTROWS( Recipes )
VAR MaxScore    = MAXX( Recipes, [Scaled Efficiency Score] )
VAR MinScore    = MINX( Recipes, [Scaled Efficiency Score] )
VAR TopRecipes  = FILTER( Recipes, [Scaled Efficiency Score] = MaxScore )
VAR CountTop    = COUNTROWS( TopRecipes )
VAR FirstRecipe = FIRSTNONBLANK( Recipes,    Dim_Recipe[Recipe] )
VAR TopRecipe   = FIRSTNONBLANK( TopRecipes, Dim_Recipe[Recipe] )

RETURN
SWITCH(
    TRUE(),
    CountRec = 0,
        "No recipes match current filters",

    PW = 0 && CW = 0 && SW = 0 && XW = 0,
        "All weights are zero; adjust to find a winner, then click column in chart to see KPIs",

    CountRec = 1,
        "Selected recipe: " & FirstRecipe,

    MaxScore = MinScore,
        "All recipes tied â€” try different weights or refine filters",

    CountTop > 1,
        "Top recipes tied: " & CONCATENATEX( TopRecipes, Dim_Recipe[Recipe], ", " ),

    ISINSCOPE( Dim_Appliance[Appliance] ),
        "Best recipe in " & SelectedAppliance & ": " & TopRecipe,

    "Best recipe: " & TopRecipe
)
```

This handles ties, blanks, and unhelpful filter situations with a friendly message.

---

## Summary of the Logic

1. **Total up raw values** (profit, XP, etc.)
2. **Normalize** everything to a 0â€“1 range  
   â€“ Single recipe: normalize vs global max  
   â€“ Multiple recipes: normalize vs appliance-level average
3. **Apply weights** to emphasize or de-emphasize traits
4. **Raise values to those weights**
5. **Multiply weighted metrics, divide by penalized ones**
6. **Scale the final scores**  
7. **Pick the best result** using that scaled score

All fully dynamic, filter-aware, and powered by DAX.

---

## Future Features

- Add cost of using an appliance (opportunity cost modeling)
- Tornado charts to visualize which weights influence the score most
- Appliance-aware optimal combos

---

### Explore Other Sections

- [`docs/data_model_overview.md`](./data_model_overview.md) â€“ Table relationships  
- [`docs/power_query_overview.md`](./power_query_overview.md) â€“ ETL design  
- [`docs/visuals_overview.md`](./visuals_overview.md) â€“ Layout and interactions

---
